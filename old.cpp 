// GoodFeaturesToTrack.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include<stdio.h>
#include <cv.h>
#include <highgui.h>
#define IMGDATA(image,i,j,k) ((char*)&image->imageData[(i)*(image->widthStep) + (j)*(image->nChannels) + (k)])
#define sizee 10
// *IMGDATA(mandel,(int)i,(int)j,0)=144+(255-144)*it/((float)max_it);
typedef struct _nonzeropoints{
    int X;
    int Y;
    int G;
}non_zero_points;
IplImage * createImage(int w, int h)
{
   IplImage * img = NULL;
   img = cvCreateImage(cvSize(w,h),IPL_DEPTH_8U,3);
   return img;
}
non_zero_points* cvFillPoints(const IplImage* in,int *numberofpoints)
{
    non_zero_points* nzp;
    int w=in->width;
    int h=in->height;
    int i,j,k=0;
    int count=0;
    for(i=0;i<w;i++)
    {
        for(j=0;j<h;j++)
        {
            if(*IMGDATA(in,i,j,0)!=0)
            {
                count++;
            }
        }
    }
    nzp=(non_zero_points*)malloc(count*sizeof(non_zero_points));
    for(i=0;i<w;i++)
    {
        for(j=0;j<h;j++)
        {
            if(*IMGDATA(in,i,j,0)!=0)
            {
                nzp[k].X=i;
                nzp[k].Y=j;
                nzp[k].G=abs(*IMGDATA(in,i,j,0));
                //printf("\nPIXEL INFO::%d",nzp[k].G);
                k++;
            }
        }
    }
    if(k==count) printf("\nArray filled succesfully with %d points",count);
    else printf("\nFailed");
    *numberofpoints=count;
    return nzp;
}
void initarr(int count_array[][sizee])
{
    int i,j;
    for(i=0;i<sizee;i++){
        for(j=0;j<sizee;j++){
            count_array[i][j]=0;
        }
    }
}
void printarr(int count_array[][sizee])
{
    int i,j;
    for(i=0;i<sizee;i++){
        printf("\n");
        for(j=0;j<sizee;j++){
            printf(" %d ",count_array[i][j]);
        }
    }
}
void cvFillLocal(non_zero_points* nzp,int total_points,non_zero_points* nzptr[][sizee],int count_array[][sizee])
{
    int k;
    int icell,jcell;
    int i,j;
    for(k=0;k<total_points;k++)
    {
        icell=(int)(nzp[k].X*sizee)/1000;
        jcell=(int)(nzp[k].Y*sizee)/1000;
        count_array[icell][jcell]=count_array[icell][jcell]+1;
    }
    for(i=0;i<sizee;i++){
        for(j=0;j<sizee;j++){
             nzptr[i][j]=(non_zero_points*)malloc(count_array[i][j]*sizeof(non_zero_points));
        }
    }
    initarr(count_array);
    for(k=0;k<total_points;k++)
    {
        icell=(int)(nzp[k].X*sizee)/1000;
        jcell=(int)(nzp[k].Y*sizee)/1000;
        nzptr[icell][jcell][count_array[icell][jcell]]=nzp[k];
        count_array[icell][jcell]++;
        //printf("\n$ k::%d $G::%d , X::%d , Y::%d$",k,nzptr[icell][jcell][count_array[icell][jcell]].G,nzptr[icell][jcell][count_array[icell][jcell]].X,nzptr[icell][jcell][count_array[icell][jcell]].Y);
    }
}
double ind(non_zero_points* nzp,int idx,int i,int j)
{
    int x;
    double r;
    x=nzp[idx].X-i;
    int y;
    y=nzp[idx].Y-j;
    r=1/sqrt(x*x+y*y);
    return r;
}
double indi(non_zero_points nzp,int i,int j)
{
    int x;
    double r;
    x=nzp.X-i;
    int y;
    y=nzp.Y-j;
    r=1/sqrt(x*x+y*y);
    return r;
}
double dist(non_zero_points* nzp,int idx,int i,int j)
{
    int x;
    int y;
    double r;
    x=nzp[idx].X-i;
    y=nzp[idx].Y-j;
    r=sqrt(x*x+y*y);
    return r;
}
void init(IplImage* in)
{
    int w=in->width;
    int h=in->height;
    int i,j;
    for(i=0;i<w;i++)
    {
        for(j=0;j<h;j++)
        {
            *IMGDATA(in,i,j,0)=0;
        }
    }
}
void kill(IplImage* in,int k)
{
    int w=in->width;
    int h=in->height;
    int i,j;
    printf("\nKILL");
    for(i=0;i<w;i++)
    {
        for(j=0;j<h;j++)
        {
            *IMGDATA(in,i,j,0)=k;
        }
    }
}
IplImage* idw(IplImage* in,non_zero_points *nzp,int Blocksize,int numberofpoints,non_zero_points* nzpptr[][sizee],int count_array[][sizee])
{
    int w=in->width;
    int h=in->height;
    int i,j,k=0,I,J;
    IplImage* out;
    double num=0,den=0;
    double dweight;
    int iweight,itemp,jtemp;
    int l;
    float p;
    int flag;
    out=cvCreateImage(cvGetSize(in),in->depth,in->nChannels);
    init(out);
    cvNamedWindow("output",CV_WINDOW_AUTOSIZE);
    kill(out,255);
    cvWaitKey(1000);
    kill(out,0);
    cvShowImage("output",out);
    cvWaitKey(10);
    if(Blocksize==0)
    {
        for(i=0;i<h;i++)
        {
            for(j=0;j<w;j++)
            {
                flag=0;
                I=i*sizee/1000;
                J=j*sizee/1000;
                if(*IMGDATA(out,i,j,0)==0)
                {
                    if(*IMGDATA(in,i,j,0)==0)
                    {
                    den=0;
                    num=0;
                    if(1)
                    {
                    for(k=0;k<numberofpoints;k++)
                    {
                        den=den+ind(nzp,k,i,j);
                        num=num+ind(nzp,k,i,j)*(nzp[k].G);
                    }
                    }
                    if(0)
                    {
                        for(itemp=I-1;itemp<I+2;itemp++)
                        {
                            for(jtemp=J-1;jtemp<J+2;jtemp++)
                            {
                                for(k=0;k<count_array[itemp][jtemp];k++)
                                {
                                    den=den+ind(nzpptr[itemp][jtemp],k,i,j);
                                    num=num+ind(nzpptr[itemp][jtemp],k,i,j)*(nzpptr[itemp][jtemp][k].G);
                                }
                            }
                        }
                    }
                    if(den!=0)
                    {
                        dweight=num/den;
                        iweight=(int)dweight;
                        *IMGDATA(out,i,j,0)=iweight;
                        //printf("\nNOW AT(%d,%d) with %d",i,j,iweight);
                    }
                    flag=1;
                    }
                if(den==0)
                {
                    *IMGDATA(out,i,j,0)=abs(*IMGDATA(in,i,j,0));
                }
                if(flag==0)
                {
                    *IMGDATA(out,i,j,0)=abs(*IMGDATA(in,i,j,0));
                }
                   p=(1000*i+j)/(10000.0);
                   printf("\n %::%f $ (%d,%d)->%d $",p,i,j,*IMGDATA(out,i,j,0));
                }
                //kill(out);
                cvWaitKey(1);
                cvShowImage("output",out);
            }
        }
    }
    else
    {

    }
    cvDestroyWindow("output");
    return out;
}
int main()
{
	// Load a color image, and convert it into grayscale
    //IplImage* img = cvLoadImage("a.jpg");
	//IplImage* fore=cvLoadImage("f.jpg");
	IplImage* img = cvLoadImage("bandaac.jpg");
    IplImage* fore=cvLoadImage("bandffc.jpg");
    //IplImage* img= cvLoadImage("aft.jpg");
	//IplImage* fore=cvLoadImage("fore.jpg");
	//IplImage*   img=cvLoadImage("le.png",CV_LOAD_IMAGE_COLOR);
   // IplImage*   fore=cvLoadImage("ri.png",CV_LOAD_IMAGE_COLOR);
	IplImage* imgGrayscale = cvCreateImage(cvGetSize(img), 8, 1);
	IplImage* imgGrayscalefore=cvCreateImage(cvGetSize(fore),8,1);
    IplImage* dimgGrayscale = cvCreateImage(cvGetSize(img), 8, 1);
	IplImage* dimgGrayscalefore=cvCreateImage(cvGetSize(fore),8,1);
	cvSet(imgGrayscale, cvScalar(0,0,0));
	cvSet(imgGrayscalefore, cvScalar(0,0,0));
	cvCvtColor(img, dimgGrayscale, CV_BGR2GRAY);
    cvCvtColor(fore,dimgGrayscalefore,CV_BGR2GRAY);
	// Create temporary images required by cvGoodFeaturesToTrack
	IplImage* imgTemp = cvCreateImage(cvGetSize(img), 32, 1);
	IplImage* imgEigen = cvCreateImage(cvGetSize(img), 32, 1);
	IplImage* imgTempfore = cvCreateImage(cvGetSize(fore), 32, 1);
	IplImage* imgEigenfore = cvCreateImage(cvGetSize(fore), 32, 1);
	IplImage* aftpoint=cvCreateImage(cvGetSize(img),IPL_DEPTH_8U,1);
	IplImage* forepoint=cvCreateImage(cvGetSize(img),IPL_DEPTH_8U,1);
	IplImage* aftcanny=cvCreateImage(cvGetSize(img),IPL_DEPTH_8U,1);
	IplImage* forecanny=cvCreateImage(cvGetSize(img),IPL_DEPTH_8U,1);
	int count =3000;
	int countfore=3000;
	CvPoint2D32f* corners = new CvPoint2D32f[count];
    CvPoint2D32f* cornersfore=new CvPoint2D32f[countfore];
    //cvSobel(dimgGrayscale,imgGrayscale,1,1,7);
    //cvSobel(dimgGrayscalefore,imgGrayscalefore,1,1,7);

	cvGoodFeaturesToTrack(dimgGrayscale, imgEigen, imgTemp, corners, &count, 0.05, 5);
    cvGoodFeaturesToTrack(dimgGrayscalefore,imgEigenfore,imgTempfore,cornersfore,&countfore,0.05,5);
	for(int i=0;i<count;i++)
	{
		cvLine(imgGrayscale, cvPoint(corners[i].x, corners[i].y), cvPoint(corners[i].x, corners[i].y), CV_RGB(255,0,255),1);
	}
	for(int i=0;i<countfore;i++)
	{
		cvLine(imgGrayscalefore,cvPoint(cornersfore[i].x, cornersfore[i].y),cvPoint(cornersfore[i].x, cornersfore[i].y), CV_RGB(255,0,255),1);
	}

	cvNamedWindow("Afterward");
	cvShowImage("Afterward", imgGrayscale);
    cvNamedWindow("Foreward");
    cvShowImage("Foreward",imgGrayscalefore);
	printf("Count in Afterward:is %d\n", count);
    printf("Count in foreward is %d\n",countfore);
    IplImage* a;
    IplImage* f;
    IplImage* d;
    IplImage* vd;
    IplImage* block;
    CvStereoBMState *BMState = cvCreateStereoBMState();
    assert(BMState != 0);
    /*
    //Default Created for Camera::
    BMState->preFilterSize=41;
    BMState->preFilterCap=31;
    BMState->SADWindowSize=41;
    BMState->minDisparity=-64;
    BMState->numberOfDisparities=128;
    BMState->textureThreshold=10;
    BMState->uniquenessRatio=15;
    */
    IplImage* vdg;
    BMState->SADWindowSize=11;
    //printf("BMSTatE SAD Window size::%d",BMState->SADWindowSize);
    d=cvCreateImage(cvGetSize(aftpoint),IPL_DEPTH_16S,1);
    vd=cvCreateImage(cvGetSize(aftpoint),IPL_DEPTH_8U,1);
    vdg=cvCreateImage(cvGetSize(aftpoint),IPL_DEPTH_8U,1);
    cvFindStereoCorrespondenceBM(imgGrayscale,imgGrayscalefore,d,BMState);
    //cvFindStereoCorrespondenceBM(dimgGrayscale,dimgGrayscalefore,d,BMState);
    cvNamedWindow("DISPARITY",CV_WINDOW_AUTOSIZE);
    cvNormalize( d, vd,0,255, CV_MINMAX );
    int k;
    cvSmooth(vd,vdg,CV_GAUSSIAN,1,0,0,0);
    cvShowImage("DISPARITY",vdg);

    for(k=0;k<30;k++)
    {
        printf("\nGAUSSSIAN %d",k);
        cvSmooth(vdg,vdg,CV_GAUSSIAN,2*k+1,0,0,0);
        cvNormalize(vdg,vdg,0,255,CV_MINMAX);
        cvShowImage("DISPARITY",vdg);
        cvWaitKey(100);
    }

    cvSmooth(vdg,vdg,CV_GAUSSIAN,3,0,0,0);
    cvNormalize(vdg,vdg,0,255,CV_MINMAX);
    cvShowImage("DISPARITY",vdg);
    cvSaveImage("Disparity_Gaussian.jpg",vdg);
    non_zero_points* nzp;
    non_zero_points* nzptr[sizee][sizee];
    int *numberofpoints;
    int count_array[sizee][sizee];
    initarr(count_array);
    numberofpoints=(int*)malloc(sizeof(int));
    nzp=cvFillPoints(vd,numberofpoints);
    cvFillLocal(nzp,*numberofpoints,nzptr,count_array);

    printarr(count_array);

    IplImage* afteridw;
    IplImage* resized;
    afteridw=idw(vdg,nzp,0,*numberofpoints,nzptr,count_array);
    cvNamedWindow("Interpolated",CV_WINDOW_AUTOSIZE);
    //cvSmooth(vd,vd,CV_GAUSSIAN,3,0, 0, 0);

    cvSaveImage("Result_Without_Interpolation.jpg",vd);
    cvShowImage("Interpolated",afteridw);
    cvSaveImage("Result.jpg",afteridw);
    cvWaitKey(0);
    cvDestroyWindow("Afterward");
    cvDestroyWindow("Foreward");
    cvDestroyWindow("histogram");
    cvDestroyWindow("Interpolated");
    cvWaitKey(0);
    cvDestroyWindow("DISPARITY");

    return 0;
}